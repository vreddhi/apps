// EventReference instances are keys, and objects with information about a
// callback are values.
var allHandlersPrivateData = new WeakMap();

function useCallback(emitter, eventReference, args) {
  var privateData = allHandlersPrivateData.get(eventReference);

  privateData.callback.apply(emitter, args);
  privateData.count--;

  return privateData.count === 0;
}

function getEventName(EventReference) {
  return allHandlersPrivateData.get(EventReference).eventName;
}

// EventReference instances are used as keys to get information about event
// callbacks. An event can also be cancelled with an EventReference instance.
function EventReference(eventName, callback, count) {
  allHandlersPrivateData.set(this, { eventName: eventName, callback: callback, count: count });
}

// This WeapMap instance has EventEmitter instances as keys, and Map instances
// as values. The Map instances have event names as keys, and Set instances as
// values. The Set instance associated with an event name contains all the
// EventHandler instances associated with the event with that name for that
// emitter.
var allEventsForAllEmitters = new WeakMap();

function checkArgs(eventName, callback, count) {
  if (typeof eventName !== 'string') {
    throw new TypeError('Event name must be a string.');
  }

  if (typeof callback !== 'function') {
    throw new TypeError('Callback must be a function.');
  }

  if (typeof count !== 'number') {
    throw new TypeError('When given, count must be a number.');
  }

  if (count !== Infinity && (Math.floor(count) !== count || count < 1)) {
    throw new RangeError('Count must not be set to an integer less than zero or a non-integer.');
  }
}

function EventEmitter() {
  if (!(this instanceof EventEmitter)) {
    return new EventEmitter();
  }

  allEventsForAllEmitters.set(this, new Map());
}

EventEmitter.prototype.on = function (eventName, callback, uncheckedCount) {
  var count = uncheckedCount === undefined ? Infinity : uncheckedCount;

  checkArgs(eventName, callback, count);

  var allEventsForThisEmitter = allEventsForAllEmitters.get(this);
  var allEventsForThisEventName = allEventsForThisEmitter.get(eventName);
  var eventReference = new EventReference(eventName, callback, count);

  if (!allEventsForThisEventName) {
    allEventsForThisEventName = new Set();
    allEventsForThisEmitter.set(eventName, allEventsForThisEventName);
  }

  allEventsForThisEventName.add(eventReference);

  return eventReference;
};

EventEmitter.prototype.off = function (handler) {
  var eventName = getEventName(handler);
  var allEventsForThisEmitter = allEventsForAllEmitters.get(this);
  var allEventsForThisEventName = allEventsForThisEmitter.get(eventName);

  if (allEventsForThisEventName) {
    allEventsForThisEventName.delete(handler);
  }
};

EventEmitter.prototype.trigger = function (eventName) {
  var allEventsForThisEmitter = allEventsForAllEmitters.get(this);
  var allEventsForThisEventName = allEventsForThisEmitter.get(eventName) || [];
  var args = Array.prototype.slice.call(arguments, 1);
  var emitter = this;

  allEventsForThisEventName.forEach(function (eventReference) {
    var done = useCallback(emitter, eventReference, args);

    if (done) {
      allEventsForThisEventName.delete(eventReference);
    }
  });
};

EventEmitter.prototype.emit = EventEmitter.prototype.trigger;

EventEmitter.prototype.allOff = function (eventName) {
  var allEventsForThisEmitter = allEventsForAllEmitters.get(this);

  if (typeof eventName === 'string') {
    allEventsForThisEmitter.delete(eventName);
  } else {
    allEventsForThisEmitter.clear();
  }
};

function randomHexByte() {
  const hexByte = Math.floor(Math.random() * 256).toString(16);

  return hexByte.length === 2 ? hexByte : `0${hexByte}`;
}

function bytes(num) {
  let randomHex = '';

  for (let i = 0; i < num; i++) {
    randomHex += randomHexByte();
  }

  return randomHex;
}

function special() {
  return ['8', '9', 'a', 'b'][Math.floor(Math.random() * 4)];
}

function uuidv4() {
  return `${bytes(4)}-${bytes(2)}-4${bytes(3)}-${special()}${bytes(3)}-${bytes(6)}`;
}

class Job {
  constructor(spec) {
    if (!spec) {
      throw new Error('Spec must be an object');
    }

    if (spec.message === undefined) {
      throw new Error('Message argument must be populated.');
    }

    this.time = spec.time instanceof Date ? spec.time.getTime() : parseInt(spec.time, 10);

    if (!this.time) {
      throw new TypeError('Time must be a Date object or an integer.');
    }

    this.message = spec.message;

    this.uuid = spec.uuid || uuidv4();
  }
}

const jobs = new WeakMap();
const timeouts = new WeakMap();

function getJobFromQueue(queue, uuid) {
  for (let i = 0, len = queue.length; i < len; i++) {
    if (queue[i].uuid === uuid) {
      return queue[i];
    }
  }
}

function makeTimeout(rb, queue) {
  clearTimeout(timeouts.get(rb));

  if (!queue.length) {
    return timeouts.set(rb, null);
  }

  // setTimeout accepts 32bit integers for the time value. If the next job is
  // later than this, we'll set a shorter timeout as a waypoint.
  const dt = Math.min(Math.max(queue[0].time - Date.now(), 0), 2147483647);

  timeouts.set(rb, setTimeout(() => {
    while (queue.length && queue[0].time <= Date.now()) {
      rb.emit('job', queue.shift());
    }

    makeTimeout(rb, queue);
  }, dt));
}

class Rubidium extends EventEmitter {
  constructor() {
    super();

    jobs.set(this, []);

    timeouts.set(this, null);
  }

  add(spec, silent) {
    const queue = jobs.get(this);
    const job = new Job(spec);

    queue.push(job);
    queue.sort((a, b) => a.time - b.time);

    if (!silent) {
      this.emit('addJob', job);
    }

    if (job === queue[0]) {
      makeTimeout(this, queue);
    }

    return job;
  }

  find(uuid) {
    return getJobFromQueue(jobs.get(this), uuid);
  }

  remove(uuid, silent) {
    const queue = jobs.get(this);
    const job = getJobFromQueue(queue, uuid);

    if (!job) {
      return;
    }

    const index = queue.indexOf(job);

    queue.splice(index, 1);

    if (!silent) {
      this.emit('removeJob', job);
    }

    if (index === 0) {
      makeTimeout(this, queue);
    }

    return job;
  }

  clear(silent) {
    const newJobs = [];

    makeTimeout(this, newJobs);

    const oldJobs = jobs.get(this);

    jobs.set(this, newJobs);

    if (silent) {
      return;
    }

    for (let i = 0, len = oldJobs.length; i < len; i++) {
      this.emit('removeJob', oldJobs[i]);
    }

    this.emit('clearJobs');
  }

  get hasPendingJobs() {
    return jobs.get(this).length !== 0;
  }
}

export default Rubidium;
